# cs5004_game

In the source folder, We use two packages to organize this project. One is "enginedriver", which contains the controller and major compositions of the whole gameplay, the other one is "jsonreader", which is responsible for initializing, saving, and restoring the game world by reading and modifying the json file.

In the "enginedriver" package, There are 3 major classes controlling the gameplay process. We have GameEngineApp to start the game play, GameController to process the command from the user, and GameWorld to store all the room informations. In the game compositions, we designed four interfaces: IIdentifiableEntity, IValuable, IWeightable, and IProblem. Among them, IIdentifiableEntity is the highest interface, representing all objects with id, name, description, and picture, and we designed abstract class IIdentifiableEntity and EntityContainer to implement this interface. Abstract class IIdentifiableEntity is composed by getter methods of the basic instance variables to reduce code duplication, and EntityContainer defines a high level of abstraction by providing many generic methods that can be reused across different subclasses, allowing them to get all kinds of elements they contained either by string form of name or by type. IValuable represents things with value which can increase the player's final score after they solving it or picking it up, like puzzles, monsters, and items, and we wrote IProblem to extend IValuable, which particularly inherited by puzzle and monster. IWeightable is used to represent elements with a weight, including item and fixture. For the concrete class, we defined basic game elements including Fixturem, Item, Player, Monster, Problem and Puzzle.

In the "jsonreader" package, we developed GameDataLoader to invoke all kinds of game initializer including GameControllerDeserializer, GameWorldDeserializer, and PlayerDeserializer. These deserializers focus on initializing specific parts of the game play by decoding data from json file.

Compared our current implementation with our idea for the last homework, one major difference is that we added several more interfaces and abstract classes like IProblem, IValuable, and EntityCotainer. These interfaces and abstract classes makes it easier to make different objects with the some same basic characteristics to be generic types. Besides, abstract classes can also reduce code duplecation and increase the conciseness. Apart from that, our current implementation is more specifc and concrete about how to read and load json data, while before we only had a very vague and simple idea about realizing this functionality. All these differences show our progross in forming a more clear vision of the whole project.

In the viewer package, we've implemented an interface called IView, and it serves as the foundation for all user interfaces. We then have two classes representing the graphic layout and the text layout of the game: GraphicView and TextView, respectively. Both classes extend from the IView interface, implementing main functions such as input handling and displaying player status. This integrates with our model allowing players to navigate through different rooms and interact with puzzle and monsters as mentioned earlier. The JSON files load the game dynamically making the game and the GUI interface customizable. To be specific, our GameController processes player commands through processCommand() method and updates the graphic and text view as the player navigates the game. Players will be able to see several things, including but not limited to a picture representing the room they're in, buttons for moving between rooms, a narrator, and the status of the game.

Lastly, we would like to give a shoutout to our TAs Brandan, Megan and Soni for their guidance and patience with our team. The project would've been a disaster without your help. Thank you so much.
